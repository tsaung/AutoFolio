import { adminClient } from "@/lib/db/admin";
import { processDocument } from "./pipeline";
import { Database } from "@/types/database";

type Project = Database["public"]["Tables"]["projects"]["Row"];
type Experience = Database["public"]["Tables"]["experiences"]["Row"];
type Skill = Database["public"]["Tables"]["skills"]["Row"];

export const PORTFOLIO_PROJECTS_TITLE = "Portfolio: Projects";
export const PORTFOLIO_EXPERIENCES_TITLE = "Portfolio: Experiences";
export const PORTFOLIO_SKILLS_TITLE = "Portfolio: Skills";

/**
 * Syncs all portfolio data to the knowledge base.
 */
export async function syncAllPortfolioData(userId: string) {
  await Promise.all([
    syncProjectsToKnowledge(userId),
    syncExperiencesToKnowledge(userId),
    syncSkillsToKnowledge(userId),
  ]);
}

/**
 * Syncs projects to the knowledge base.
 */
export async function syncProjectsToKnowledge(userId: string) {
  const { data: projects } = await adminClient
    .from("projects")
    .select("*")
    .eq("user_id", userId)
    .eq("status", "published")
    .order("sort_order", { ascending: true });

  if (!projects) return;

  const content = formatProjects(projects);
  await upsertAutoGeneratedDocument(userId, PORTFOLIO_PROJECTS_TITLE, content);
}

/**
 * Syncs experiences to the knowledge base.
 */
export async function syncExperiencesToKnowledge(userId: string) {
  const { data: experiences } = await adminClient
    .from("experiences")
    .select("*")
    .eq("user_id", userId)
    .order("sort_order", { ascending: true });

  if (!experiences) return;

  const content = formatExperiences(experiences);
  await upsertAutoGeneratedDocument(
    userId,
    PORTFOLIO_EXPERIENCES_TITLE,
    content,
  );
}

/**
 * Syncs skills to the knowledge base.
 */
export async function syncSkillsToKnowledge(userId: string) {
  const { data: skills } = await adminClient
    .from("skills")
    .select("*")
    .eq("user_id", userId)
    .order("sort_order", { ascending: true });

  if (!skills) return;

  const content = formatSkills(skills);
  await upsertAutoGeneratedDocument(userId, PORTFOLIO_SKILLS_TITLE, content);
}

/**
 * Helper to upsert a knowledge document and trigger processing.
 */
async function upsertAutoGeneratedDocument(
  userId: string,
  title: string,
  content: string,
) {
  // Check if document exists
  const { data: existing } = await adminClient
    .from("knowledge_documents")
    .select("id")
    .eq("user_id", userId)
    .eq("title", title)
    .eq("type", "auto_generated")
    .single();

  let documentId = existing?.id;

  if (documentId) {
    // Update
    const { error } = await adminClient
      .from("knowledge_documents")
      .update({
        content,
        updated_at: new Date().toISOString(),
        status: "active", // Resurrect if archived
      })
      .eq("id", documentId);

    if (error) {
      console.error(
        `[Portfolio Sync] Failed to update document ${title}:`,
        error,
      );
      return;
    }
  } else {
    // Create
    const { data, error } = await adminClient
      .from("knowledge_documents")
      .insert({
        user_id: userId,
        title,
        content,
        type: "auto_generated",
        status: "active",
      })
      .select("id")
      .single();

    if (error) {
      console.error(
        `[Portfolio Sync] Failed to create document ${title}:`,
        error,
      );
      return;
    }
    documentId = data.id;
  }

  // Trigger RAG processing
  // Note: We use processDocument directly.
  // In a real message queue system, we'd enqueue a job.
  // Here we rely on the caller (server action) to wrap this in `after()`.
  if (documentId) {
    await processDocument(documentId, userId, content);
  }
}

/**
 * Formats projects into Markdown.
 */
export function formatProjects(projects: Project[]): string {
  if (projects.length === 0) return "No projects listed.";

  return projects
    .map((p) => {
      let md = `# ${p.title}\n`;
      if (p.description) md += `${p.description}\n\n`;
      if (p.tags && p.tags.length > 0) {
        md += `- **Tech Stack**: ${p.tags.join(", ")}\n`;
      }
      if (p.live_url) md += `- [Live Demo](${p.live_url})\n`;
      if (p.repo_url) md += `- [Source Code](${p.repo_url})\n`;
      return md;
    })
    .join("\n---\n\n");
}

/**
 * Formats experiences into Markdown.
 */
export function formatExperiences(experiences: Experience[]): string {
  if (experiences.length === 0) return "No experience listed.";

  return experiences
    .map((e) => {
      const dates = `${e.start_date} - ${e.end_date || "Present"}`;
      let md = `## ${e.title} at ${e.company}\n`;
      md += `**${dates}** | ${e.location || "Remote"}\n\n`;
      if (e.description) md += `${e.description}\n`;
      return md;
    })
    .join("\n\n");
}

/**
 * Formats skills into Markdown.
 */
export function formatSkills(skills: Skill[]): string {
  if (skills.length === 0) return "No skills listed.";

  // Group by category
  const byCategory: Record<string, Skill[]> = {};
  skills.forEach((s) => {
    if (!byCategory[s.category]) byCategory[s.category] = [];
    byCategory[s.category].push(s);
  });

  return Object.entries(byCategory)
    .map(([category, items]) => {
      let md = `## ${category}\n`;
      items.forEach((s) => {
        md += `- ${s.name} (${s.proficiency || "?"}/5)\n`;
      });
      return md;
    })
    .join("\n");
}
